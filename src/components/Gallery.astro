---
const photos = [
  "/photos/photo5.jpg",
  "/photos/02.jpg",
  "/photos/03.jpg",
  "/photos/04.jpg",
  "/photos/07.jpg",
  "/photos/photo1.jpg",
  "/photos/11.jpg",
  "/photos/12.jpg",
  "/photos/photo2.jpg",
  "/photos/photo8.jpg",
  "/photos/14.jpg",
  "/photos/10.jpg",
];
---

<section class="min-h-screen flex flex-col">
  <div class="flex items-end justify-center">
    <h2 class="text-lg font-normal text-cartier font-gowoon tracking-[0.08em] mb-3">GALLERY</h2>
  </div>

  <!-- 정사각형 썸네일: 2열 -->
  <div class="mt-4 grid grid-cols-2 gap-2">
    {photos.map((src, i) => (
      <button
        type="button"
        class="group relative overflow-hidden rounded-lg"
        data-lightbox="open"
        data-index={i}
        aria-label={`사진 크게 보기 ${i + 1}`}
      >
        <img
          src={src}
          alt={`gallery ${i + 1}`}
          class="aspect-square w-full object-cover transition duration-300 group-hover:scale-[1.02]"
          loading="lazy"
          decoding="async"
        />
      </button>
    ))}
  </div>

  <!-- 라이트박스(풀스크린) -->
  <div id="lightbox" class="fixed inset-0 z-50 hidden bg-black/90" aria-hidden="true">
    <!-- 닫기 -->
    <button
      id="lbClose"
      type="button"
      class="absolute right-4 top-4 z-10 grid h-9 w-9 place-items-center text-white cursor-pointer"
      aria-label="닫기"
    >
      <svg viewBox="0 0 24 24" class="h-5 w-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <path d="M6 6l12 12M18 6L6 18" />
      </svg>
    </button>

    <!-- 내용 레이아웃(위: 큰 사진, 아래: 썸네일) -->
    <div class="h-dvh w-full flex flex-col px-4 pt-14 pb-4">
      <!-- 큰 사진 영역 -->
      <div class="flex-1 flex items-center justify-center">
        <div class="relative w-full max-w-[520px]">
          <div
            id="lbViewport"
            class="relative mx-auto h-[70dvh] w-full overflow-hidden rounded-2xl shadow-2xl flex items-center justify-center touch-none"
          >
            <img
              id="lbImg"
              src=""
              alt="selected photo"
              class="max-h-full max-w-full object-contain select-none"
              draggable="false"
            />
          </div>

          <!-- Prev/Next -->
          <button
            id="lbPrev"
            type="button"
            class="absolute left-2 sm:-left-10 top-1/2 -translate-y-1/2 z-20 grid h-9 w-9 place-items-center rounded-full bg-black/35 ring-1 ring-white/15 text-white backdrop-blur opacity-80 hover:opacity-100 transition cursor-pointer"
            aria-label="이전 사진"
          >
            <svg viewBox="0 0 24 24" class="h-5 w-5" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M15 18l-6-6 6-6" />
            </svg>
          </button>

          <button
            id="lbNext"
            type="button"
            class="absolute right-2 sm:-right-10 top-1/2 -translate-y-1/2 z-20 grid h-9 w-9 place-items-center rounded-full bg-black/35 ring-1 ring-white/15 text-white backdrop-blur opacity-80 hover:opacity-100 transition cursor-pointer"
            aria-label="다음 사진"
          >
            <svg viewBox="0 0 24 24" class="h-5 w-5" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 18l6-6-6-6" />
            </svg>
          </button>
        </div>
      </div>

      <!-- 카운트 -->
      <p id="lbCount" class="mt-2 text-center text-xs text-white/70"></p>

      <!-- 썸네일 스트립 -->
      <div class="mt-3">
        <div class="mx-auto max-w-[520px] px-4">
          <div id="lbStrip" class="mt-3 flex gap-2 overflow-x-auto pb-1 scroll-smooth no-scrollbar">
            {photos.map((src, i) => (
              <button
                type="button"
                class="lb-thumb shrink-0 rounded-lg overflow-hidden ring-2 ring-transparent"
                data-thumb-index={i}
                aria-label={`썸네일 ${i + 1}`}
              >
                <img
                  src={src}
                  alt={`thumb ${i + 1}`}
                  class="h-14 w-14 object-cover opacity-70"
                  loading="lazy"
                  decoding="async"
                  draggable="false"
                />
              </button>
            ))}
          </div>
        </div>
      </div>
    </div>
  </div>

  <script is:inline define:vars={{ photos }}>
    const PHOTOS = photos;

    const lb = document.getElementById("lightbox");
    const lbImg = document.getElementById("lbImg");
    const lbCount = document.getElementById("lbCount");
    const strip = document.getElementById("lbStrip");

    const btnClose = document.getElementById("lbClose");
    const btnPrev = document.getElementById("lbPrev");
    const btnNext = document.getElementById("lbNext");

    const viewport = document.getElementById("lbViewport");
    const thumbButtons = Array.from(document.querySelectorAll("[data-thumb-index]"));

    let current = 0;

    // ===== Zoom/Pan state =====
    let scale = 1;
    let tx = 0;
    let ty = 0;

    const MIN_SCALE = 1;
    const MAX_SCALE = 4;

    let isPanning = false;
    let isPinching = false;

    // pointer tracking (for pinch)
    const pointers = new Map(); // id -> {x,y}
    let startDist = 0;
    let startScale = 1;
    let startTx = 0;
    let startTy = 0;
    let startMid = { x: 0, y: 0 };

    // swipe guard
    let multiTouch = false;
    let startX = null;

    // double tap guard
    let lastTap = 0;
    let justZoomed = false;

    // ✅ pinch cooldown (핀치 직후 더블탭 방지)
    let pinchCooldownUntil = 0;
    function markPinchCooldown(ms = 900) {
      pinchCooldownUntil = Date.now() + ms;
    }

    function clamp(n, a, b) {
      return Math.max(a, Math.min(b, n));
    }

    function applyTransform(withTransition = true) {
      lbImg.style.transformOrigin = "center center";
      lbImg.style.transition = withTransition ? "transform 120ms ease" : "none";
      lbImg.style.transform = `translate(${tx}px, ${ty}px) scale(${scale})`;
    }

    function clampPan() {
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;

      const maxX = (vw * (scale - 1)) / 2;
      const maxY = (vh * (scale - 1)) / 2;

      tx = clamp(tx, -maxX, maxX);
      ty = clamp(ty, -maxY, maxY);
    }

    function resetZoom() {
      scale = 1;
      tx = 0;
      ty = 0;
      applyTransform(true);
    }

    function toggleZoom() {
      if (scale === 1) {
        scale = 2;
      } else {
        scale = 1;
        tx = 0;
        ty = 0;
      }
      clampPan();
      applyTransform(true);
    }

    // ===== Thumbs =====
    function updateNavButtons() {
      btnPrev.classList.toggle("hidden", current === 0);
      btnNext.classList.toggle("hidden", current === PHOTOS.length - 1);
    }

    function highlightThumb() {
      if (!strip) return;

      thumbButtons.forEach((btn) => {
        const img = btn.querySelector("img");
        btn.classList.remove("ring-white");
        btn.classList.add("ring-transparent");
        img.classList.remove("opacity-100");
        img.classList.add("opacity-70");
      });

      const activeBtn = thumbButtons[current];
      if (!activeBtn) return;

      const activeImg = activeBtn.querySelector("img");
      activeBtn.classList.remove("ring-transparent");
      activeBtn.classList.add("ring-white");
      activeImg.classList.remove("opacity-70");
      activeImg.classList.add("opacity-100");

      const max = Math.max(0, strip.scrollWidth - strip.clientWidth);

      if (current === 0) {
        strip.scrollTo({ left: 0, behavior: "smooth" });
        return;
      }
      if (current === PHOTOS.length - 1) {
        strip.scrollTo({ left: max, behavior: "smooth" });
        return;
      }

      const target = activeBtn.offsetLeft + activeBtn.offsetWidth / 2 - strip.clientWidth / 2;
      const nextLeft = clamp(target, 0, max);
      strip.scrollTo({ left: nextLeft, behavior: "smooth" });
    }

    function render() {
      // 사진 넘길 때만 줌 초기화(아이폰 느낌)
      resetZoom();
      lbImg.src = PHOTOS[current];
      lbCount.textContent = `${current + 1} / ${PHOTOS.length}`;
      highlightThumb();
      updateNavButtons();
    }

    function openAt(index) {
      current = index;

      lb.classList.remove("hidden");
      lb.classList.add("block");
      lb.setAttribute("aria-hidden", "false");
      document.body.style.overflow = "hidden";

      render();
      setTimeout(render, 0);
    }

    function close() {
      lb.classList.add("hidden");
      lb.classList.remove("block");
      lb.setAttribute("aria-hidden", "true");
      lbImg.src = "";
      document.body.style.overflow = "";
      resetZoom();
    }

    function prev() {
      if (current === 0) return;
      current -= 1;
      render();
    }

    function next() {
      if (current === PHOTOS.length - 1) return;
      current += 1;
      render();
    }

    // ===== Open handlers =====
    document.querySelectorAll('[data-lightbox="open"]').forEach((btn) => {
      btn.addEventListener("click", () => openAt(Number(btn.dataset.index)));
    });

    thumbButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        current = Number(btn.dataset.thumbIndex);
        render();
      });
    });

    // stopPropagation important
    btnClose.addEventListener("click", (e) => {
      e.stopPropagation();
      close();
    });
    btnPrev.addEventListener("click", (e) => {
      e.stopPropagation();
      prev();
    });
    btnNext.addEventListener("click", (e) => {
      e.stopPropagation();
      next();
    });

    lb.addEventListener("click", (e) => {
      if (e.target === lb) close();
    });

    window.addEventListener("keydown", (e) => {
      if (lb.classList.contains("hidden")) return;
      if (e.key === "Escape") close();
      if (e.key === "ArrowLeft") prev();
      if (e.key === "ArrowRight") next();
    });

    // ===== Double click (PC) =====
    viewport.addEventListener("dblclick", (e) => {
      e.preventDefault();
      toggleZoom();
    });

    // ===== Double tap (mobile) =====
    viewport.addEventListener(
      "touchend",
      (e) => {
        // ✅ 핀치 직후(또는 핀치 중) 들어오는 touchend는 더블탭 판정 금지
        if (Date.now() < pinchCooldownUntil || isPinching || multiTouch) {
          lastTap = 0;
          return;
        }

        // iOS/카톡 인앱: 기본 페이지 줌 방지
        e.preventDefault();

        const now = Date.now();
        if (now - lastTap < 280) {
          toggleZoom();
          lastTap = 0;

          justZoomed = true;
          setTimeout(() => (justZoomed = false), 250);
        } else {
          lastTap = now;
        }
      },
      { passive: false }
    );

    // ===== Pointer events for pan + pinch =====
    function getDistance(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    function getMid(a, b) {
      return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
    }

    viewport.addEventListener("pointerdown", (e) => {
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      viewport.setPointerCapture?.(e.pointerId);

      if (pointers.size === 2) {
        // pinch start
        isPinching = true;
        isPanning = false;

        // ✅ 핀치 시작: 더블탭 판정 막기(핀치 끝날 때까지 + 종료 직후)
        markPinchCooldown(900);

        const pts = Array.from(pointers.values());
        startDist = getDistance(pts[0], pts[1]);
        startScale = scale;

        startTx = tx;
        startTy = ty;

        startMid = getMid(pts[0], pts[1]);

        multiTouch = true;
        startX = null;
        return;
      }

      // one finger/mouse pan only when zoomed
      if (scale > 1) {
        isPanning = true;
        isPinching = false;

        startTx = tx;
        startTy = ty;
        startMid = { x: e.clientX, y: e.clientY };
      }
    });

    viewport.addEventListener("pointermove", (e) => {
      if (!pointers.has(e.pointerId)) return;
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (isPinching && pointers.size === 2) {
        // ✅ 핀치 진행 중 계속 연장
        markPinchCooldown(900);

        const pts = Array.from(pointers.values());
        const dist = getDistance(pts[0], pts[1]);
        const mid = getMid(pts[0], pts[1]);

        let nextScale = startScale * (dist / startDist);
        nextScale = clamp(nextScale, MIN_SCALE, MAX_SCALE);

        const dxMid = mid.x - startMid.x;
        const dyMid = mid.y - startMid.y;

        const sRatio = nextScale / startScale;

        tx = startTx + dxMid + startTx * (sRatio - 1);
        ty = startTy + dyMid + startTy * (sRatio - 1);

        scale = nextScale;
        clampPan();
        applyTransform(false);
        return;
      }

      if (isPanning && pointers.size === 1 && scale > 1) {
        const p = pointers.get(e.pointerId);
        const dx = p.x - startMid.x;
        const dy = p.y - startMid.y;

        tx = startTx + dx;
        ty = startTy + dy;

        clampPan();
        applyTransform(false);
      }
    });

    function endPointer(e) {
      pointers.delete(e.pointerId);

      if (pointers.size < 2) {
        if (isPinching) markPinchCooldown(900); // ✅ 핀치 종료 직후
        isPinching = false;
      }
      if (pointers.size === 0) {
        isPanning = false;
        applyTransform(true);
        multiTouch = false;
      }
    }

    viewport.addEventListener("pointerup", endPointer);
    viewport.addEventListener("pointercancel", endPointer);

    // ===== Swipe (mobile) for next/prev - ONLY when not zoomed =====
    lb.addEventListener(
      "touchstart",
      (e) => {
        // ✅ 썸네일 스트립에서 시작하면 스와이프(다음/이전) 금지
        if (e.target.closest("#lbStrip")) {
          startX = null;
          return;
        }

        if (e.touches.length > 1) {
          multiTouch = true;
          startX = null;
          return;
        }
        multiTouch = false;

        if (scale > 1) {
          startX = null;
          return;
        }
        startX = e.touches[0].clientX;
      },
      { passive: true }
    );

    lb.addEventListener(
      "touchend",
      (e) => {
        // ✅ 썸네일 스트립에서 끝나도 스와이프 금지
        if (e.target.closest("#lbStrip")) {
          startX = null;
          return;
        }

        if (justZoomed) {
          startX = null;
          return;
        }
        if (isPanning || isPinching) {
          startX = null;
          return;
        }
        if (multiTouch) {
          multiTouch = false;
          startX = null;
          return;
        }
        if (startX === null) return;

        if (scale > 1) {
          startX = null;
          return;
        }

        const endX = e.changedTouches[0].clientX;
        const dx = endX - startX;
        startX = null;

        if (Math.abs(dx) < 40) return;
        if (dx > 0) prev();
        else next();
      },
      { passive: true }
    );
  </script>
</section>
