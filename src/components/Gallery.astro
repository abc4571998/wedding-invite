---
const photos = [
  "/photos/photo5.jpg",
  "/photos/02.jpg",
  "/photos/03.jpg",
  "/photos/04.jpg",
  "/photos/07.jpg",
  "/photos/photo1.jpg",
  "/photos/11.jpg",
  "/photos/12.jpg",
  "/photos/photo2.jpg",
  "/photos/photo8.jpg",
  "/photos/14.jpg",
  "/photos/10.jpg",
];
---

<section class="min-h-screen flex flex-col">
  <div class="flex items-end justify-center">
    <h2 class="text-lg font-normal text-cartier font-gowoon tracking-[0.08em] mb-3">GALLERY</h2>
  </div>

  <!-- 정사각형 썸네일: 2열 -->
  <div class="mt-4 grid grid-cols-2 gap-2">
    {photos.map((src, i) => (
      <button
        type="button"
        class="group relative overflow-hidden rounded-lg"
        data-lightbox="open"
        data-index={i}
        aria-label={`사진 크게 보기 ${i + 1}`}
      >
        <img
          src={src}
          alt={`gallery ${i + 1}`}
          class="aspect-square w-full object-cover transition duration-300 group-hover:scale-[1.02]"
          loading="lazy"
          decoding="async"
        />
      </button>
    ))}
  </div>

  <!-- 라이트박스(풀스크린) -->
  <div id="lightbox" class="fixed inset-0 z-50 hidden" aria-hidden="true">
    <!-- 검은 배경 -->
    <div class="absolute inset-0 bg-black/90"></div>

    <!-- 닫기 -->
    <button
      id="lbClose"
      type="button"
      class="absolute right-4 top-4 z-20 grid h-9 w-9 place-items-center text-white cursor-pointer"
      aria-label="닫기"
    >
      <svg viewBox="0 0 24 24" class="h-5 w-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <path d="M6 6l12 12M18 6L6 18" />
      </svg>
    </button>

    <div class="relative z-10 h-dvh w-full flex flex-col px-4 pt-14 pb-4">
      <!-- 큰 사진 -->
      <div class="flex-1 flex items-center justify-center">
        <div class="relative w-full max-w-[520px]">
          <div
            id="lbViewport"
            class="relative mx-auto h-[70dvh] w-full overflow-hidden rounded-2xl shadow-2xl flex items-center justify-center"
          >
            <img
              id="lbImg"
              src=""
              alt="selected photo"
              oncontextmenu="return false"
              class="absolute left-1/2 top-1/2 select-none max-w-none max-h-none"
              draggable="false"
            />
          </div>

          <!-- Prev/Next -->
          <button
            id="lbPrev"
            type="button"
            class="absolute left-2 sm:-left-10 top-1/2 -translate-y-1/2 z-20 grid h-9 w-9 place-items-center rounded-full bg-black/35 ring-1 ring-white/15 text-white backdrop-blur opacity-80 hover:opacity-100 transition cursor-pointer"
            aria-label="이전 사진"
          >
            <svg viewBox="0 0 24 24" class="h-5 w-5" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M15 18l-6-6 6-6" />
            </svg>
          </button>

          <button
            id="lbNext"
            type="button"
            class="absolute right-2 sm:-right-10 top-1/2 -translate-y-1/2 z-20 grid h-9 w-9 place-items-center rounded-full bg-black/35 ring-1 ring-white/15 text-white backdrop-blur opacity-80 hover:opacity-100 transition cursor-pointer"
            aria-label="다음 사진"
          >
            <svg viewBox="0 0 24 24" class="h-5 w-5" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 18l6-6-6-6" />
            </svg>
          </button>
        </div>
      </div>

      <p id="lbCount" class="mt-2 text-center text-xs text-white/70"></p>

      <!-- 썸네일 스트립 -->
      <div class="mt-3">
        <div class="mx-auto max-w-[520px] px-4">
          <div id="lbStrip" class="mt-3 flex gap-2 overflow-x-auto pb-1 scroll-smooth no-scrollbar">
            {photos.map((src, i) => (
              <button
                type="button"
                class="lb-thumb shrink-0 rounded-lg overflow-hidden ring-2 ring-transparent"
                data-thumb-index={i}
                aria-label={`썸네일 ${i + 1}`}
              >
                <img
                  src={src}
                  alt={`thumb ${i + 1}`}
                  class="h-14 w-14 object-cover opacity-70"
                  loading="lazy"
                  decoding="async"
                  draggable="false"
                />
              </button>
            ))}
          </div>
        </div>
      </div>
    </div>
  </div>

  <script is:inline define:vars={{ photos }}>
    const PHOTOS = photos;

    const lb = document.getElementById("lightbox");
    const lbImg = document.getElementById("lbImg");
    const lbCount = document.getElementById("lbCount");
    const strip = document.getElementById("lbStrip");

    const btnClose = document.getElementById("lbClose");
    const btnPrev = document.getElementById("lbPrev");
    const btnNext = document.getElementById("lbNext");

    const viewport = document.getElementById("lbViewport");
    const thumbButtons = Array.from(document.querySelectorAll("[data-thumb-index]"));

    // 선명도 도움(렌더링 힌트)
    lbImg.style.willChange = "transform, width, height";
    lbImg.style.transformOrigin = "center center";
    lbImg.addEventListener("contextmenu", (e) => e.preventDefault());
    lbImg.setAttribute("draggable", "false");

    let current = 0;

    // ===== ✅ 페이지 줌 상태에 따라 “브라우저 줌” 허용/차단 모드 전환 =====
    function pageScale() {
      return window.visualViewport?.scale || 1;
    }
    function isPageZoomed() {
      return pageScale() > 1.01;
    }

    function syncInteractionMode() {
      if (isPageZoomed()) {
        viewport.style.touchAction = "auto";
        pointers.clear();
        isPinching = false;
        isPanning = false;
        multiTouch = false;
      } else {
        viewport.style.touchAction = "none";
      }
    }

    if (window.visualViewport) {
      window.visualViewport.addEventListener("resize", () => {
        if (!lb.classList.contains("hidden")) syncInteractionMode();
      });
      window.visualViewport.addEventListener("scroll", () => {
        if (!lb.classList.contains("hidden")) syncInteractionMode();
      });
    }
    window.addEventListener("resize", () => {
      if (!lb.classList.contains("hidden")) syncInteractionMode();
    });

    // ===== Zoom/Pan state =====
    let baseW = 0;
    let baseH = 0;

    let scale = 1;
    let tx = 0;
    let ty = 0;

    const MIN_SCALE = 1;
    const MAX_SCALE = 4;

    let isPanning = false;
    let isPinching = false;

    const pointers = new Map(); // id -> {x,y}
    let startDist = 0;
    let startScale = 1;
    let startTx = 0;
    let startTy = 0;
    let startMid = { x: 0, y: 0 };

    let multiTouch = false;
    let startX = null;

    let lastTap = 0;
    let justZoomed = false;

    let pinchCooldownUntil = 0;
    function markPinchCooldown(ms = 900) {
      pinchCooldownUntil = Date.now() + ms;
    }

    function clamp(n, a, b) {
      return Math.max(a, Math.min(b, n));
    }

    function applyTransform(withTransition = true) {
      lbImg.style.transition = withTransition ? "transform 120ms ease" : "none";
      lbImg.style.transform = `translate(calc(-50% + ${tx}px), calc(-50% + ${ty}px))`;
    }

    function clampPanBySize(imgW, imgH) {
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;

      const maxX = Math.max(0, (imgW - vw) / 2);
      const maxY = Math.max(0, (imgH - vh) / 2);

      tx = clamp(tx, -maxX, maxX);
      ty = clamp(ty, -maxY, maxY);
    }

    function setImageSizeByScale() {
      const w = baseW * scale;
      const h = baseH * scale;
      lbImg.style.width = `${w}px`;
      lbImg.style.height = `${h}px`;
      clampPanBySize(w, h);
    }

    function measureBase() {
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;

      const naturalW = lbImg.naturalWidth || 1;
      const naturalH = lbImg.naturalHeight || 1;

      const r = Math.min(vw / naturalW, vh / naturalH);
      baseW = Math.round(naturalW * r);
      baseH = Math.round(naturalH * r);
    }

    function resetZoom() {
      scale = 1;
      tx = 0;
      ty = 0;
      setImageSizeByScale();
      applyTransform(true);
    }

    function toggleZoom() {
      scale = (scale === 1) ? 2 : 1;
      setImageSizeByScale();
      applyTransform(true);
    }

    function updateNavButtons() {
      btnPrev.classList.toggle("hidden", current === 0);
      btnNext.classList.toggle("hidden", current === PHOTOS.length - 1);
    }

    function highlightThumb() {
      if (!strip) return;

      thumbButtons.forEach((btn) => {
        const img = btn.querySelector("img");
        btn.classList.remove("ring-white");
        btn.classList.add("ring-transparent");
        img.classList.remove("opacity-100");
        img.classList.add("opacity-70");
      });

      const activeBtn = thumbButtons[current];
      if (!activeBtn) return;

      const activeImg = activeBtn.querySelector("img");
      activeBtn.classList.remove("ring-transparent");
      activeBtn.classList.add("ring-white");
      activeImg.classList.remove("opacity-70");
      activeImg.classList.add("opacity-100");

      const max = Math.max(0, strip.scrollWidth - strip.clientWidth);

      if (current === 0) {
        strip.scrollTo({ left: 0, behavior: "smooth" });
        return;
      }
      if (current === PHOTOS.length - 1) {
        strip.scrollTo({ left: max, behavior: "smooth" });
        return;
      }

      const target = activeBtn.offsetLeft + activeBtn.offsetWidth / 2 - strip.clientWidth / 2;
      const nextLeft = clamp(target, 0, max);
      strip.scrollTo({ left: nextLeft, behavior: "smooth" });
    }

    function render() {
      lbImg.onload = () => {
        measureBase();
        resetZoom();
      };

      lbImg.src = PHOTOS[current];

      lbCount.textContent = `${current + 1} / ${PHOTOS.length}`;
      highlightThumb();
      updateNavButtons();
    }

    function openAt(index) {
      current = index;

      lb.classList.remove("hidden");
      lb.classList.add("block");
      lb.setAttribute("aria-hidden", "false");
      document.body.style.overflow = "hidden";

      syncInteractionMode();

      render();
      setTimeout(render, 0);
    }

    function close() {
      lb.classList.add("hidden");
      lb.classList.remove("block");
      lb.setAttribute("aria-hidden", "true");
      lbImg.src = "";
      document.body.style.overflow = "";
    }

    function prev() {
      if (current === 0) return;
      current -= 1;
      render();
    }

    function next() {
      if (current === PHOTOS.length - 1) return;
      current += 1;
      render();
    }

    // ===== Open handlers =====
    document.querySelectorAll('[data-lightbox="open"]').forEach((btn) => {
      btn.addEventListener("click", () => openAt(Number(btn.dataset.index)));
    });

    thumbButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        current = Number(btn.dataset.thumbIndex);
        render();
      });
    });

    btnClose.addEventListener("click", (e) => { e.stopPropagation(); close(); });
    btnPrev.addEventListener("click", (e) => { e.stopPropagation(); prev(); });
    btnNext.addEventListener("click", (e) => { e.stopPropagation(); next(); });

    // ✅ 핵심: “검은 영역” 클릭 닫기 (사진/버튼/썸네일 영역이 아니면 닫기)
    lb.addEventListener("click", (e) => {
      if (lb.classList.contains("hidden")) return;

      const keepOpen = e.target.closest(
        "#lbViewport, #lbPrev, #lbNext, #lbClose, #lbStrip, [data-thumb-index]"
      );
      if (!keepOpen) close();
    });

    window.addEventListener("keydown", (e) => {
      if (lb.classList.contains("hidden")) return;
      if (e.key === "Escape") close();
      if (e.key === "ArrowLeft") prev();
      if (e.key === "ArrowRight") next();
    });

    // ===== Double click (PC) =====
    viewport.addEventListener("dblclick", (e) => {
      if (isPageZoomed()) return;
      e.preventDefault();
      toggleZoom();
    });

    // ===== Double tap (mobile) =====
    viewport.addEventListener(
      "touchend",
      (e) => {
        if (isPageZoomed()) return;

        if (Date.now() < pinchCooldownUntil || isPinching || multiTouch) {
          lastTap = 0;
          return;
        }

        e.preventDefault();

        const now = Date.now();
        if (now - lastTap < 280) {
          toggleZoom();
          lastTap = 0;

          justZoomed = true;
          setTimeout(() => (justZoomed = false), 250);
        } else {
          lastTap = now;
        }
      },
      { passive: false }
    );

    // ===== Pointer events for pan + pinch =====
    function getDistance(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    function getMid(a, b) {
      return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
    }

    viewport.addEventListener("pointerdown", (e) => {
      if (isPageZoomed()) return;

      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      viewport.setPointerCapture?.(e.pointerId);

      if (pointers.size === 2) {
        isPinching = true;
        isPanning = false;

        markPinchCooldown(900);

        const pts = Array.from(pointers.values());
        startDist = getDistance(pts[0], pts[1]);
        startScale = scale;

        startTx = tx;
        startTy = ty;

        startMid = getMid(pts[0], pts[1]);

        multiTouch = true;
        startX = null;
        return;
      }

      if (scale > 1) {
        isPanning = true;
        isPinching = false;

        startTx = tx;
        startTy = ty;
        startMid = { x: e.clientX, y: e.clientY };
      }
    });

    viewport.addEventListener("pointermove", (e) => {
      if (isPageZoomed()) return;
      if (!pointers.has(e.pointerId)) return;

      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (isPinching && pointers.size === 2) {
        const pts = Array.from(pointers.values());
        const dist = getDistance(pts[0], pts[1]);
        const mid = getMid(pts[0], pts[1]);

        let nextScale = startScale * (dist / startDist);
        nextScale = clamp(nextScale, MIN_SCALE, MAX_SCALE);

        scale = nextScale;
        setImageSizeByScale();

        const dxMid = mid.x - startMid.x;
        const dyMid = mid.y - startMid.y;
        tx = startTx + dxMid;
        ty = startTy + dyMid;

        clampPanBySize(baseW * scale, baseH * scale);

        applyTransform(false);
        return;
      }

      if (isPanning && pointers.size === 1 && scale > 1) {
        const p = pointers.get(e.pointerId);
        const dx = p.x - startMid.x;
        const dy = p.y - startMid.y;

        tx = startTx + dx;
        ty = startTy + dy;

        clampPanBySize(baseW * scale, baseH * scale);

        applyTransform(false);
      }
    });

    function endPointer(e) {
      pointers.delete(e.pointerId);

      if (pointers.size < 2) {
        if (isPinching) markPinchCooldown(900);
        isPinching = false;
      }
      if (pointers.size === 0) {
        isPanning = false;
        applyTransform(true);
        multiTouch = false;
      }
    }

    viewport.addEventListener("pointerup", endPointer);
    viewport.addEventListener("pointercancel", endPointer);

    // ===== Swipe (mobile) next/prev - ONLY when not zoomed =====
    lb.addEventListener(
      "touchstart",
      (e) => {
        if (e.target.closest("#lbStrip")) {
          startX = null;
          return;
        }

        if (e.touches.length > 1) {
          multiTouch = true;
          startX = null;
          return;
        }
        multiTouch = false;

        if (scale > 1) { startX = null; return; }
        startX = e.touches[0].clientX;
      },
      { passive: true }
    );

    lb.addEventListener(
      "touchend",
      (e) => {
        if (e.target.closest("#lbStrip")) {
          startX = null;
          return;
        }

        if (justZoomed || isPanning || isPinching) { startX = null; return; }
        if (multiTouch) { multiTouch = false; startX = null; return; }
        if (startX === null) return;
        if (scale > 1) { startX = null; return; }

        const endX = e.changedTouches[0].clientX;
        const dx = endX - startX;
        startX = null;

        if (Math.abs(dx) < 40) return;
        if (dx > 0) prev();
        else next();
      },
      { passive: true }
    );
  </script>
</section>
