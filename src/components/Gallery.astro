---
const photos = [
  "/photos/photo5.jpg",
  "/photos/02.jpg",
  "/photos/03.jpg",
  "/photos/04.jpg",
  "/photos/07.jpg",
  "/photos/photo1.jpg",
  "/photos/11.jpg",
  "/photos/12.jpg",
  "/photos/photo2.jpg",
  "/photos/photo8.jpg",
  "/photos/14.jpg",
  "/photos/10.jpg",
];
---

<section class="min-h-screen flex flex-col">
  <div class="flex items-end justify-center">
    <h2 class="text-lg font-normal text-cartier font-gowoon tracking-[0.08em] mb-3">GALLERY</h2>
  </div>

  <div class="mt-4 grid grid-cols-2 gap-2">
    {photos.map((src, i) => (
      <button
        type="button"
        class="group relative overflow-hidden rounded-lg"
        data-lightbox="open"
        data-index={i}
        aria-label={`사진 크게 보기 ${i + 1}`}
      >
        <img
          src={src}
          alt={`gallery ${i + 1}`}
          class="aspect-square w-full object-cover transition duration-300 group-hover:scale-[1.02]"
          loading="lazy"
          decoding="async"
        />
      </button>
    ))}
  </div>

  <div id="lightbox" class="fixed inset-0 z-50 hidden bg-black/90" aria-hidden="true">
    <button
      id="lbClose"
      type="button"
      class="absolute right-4 top-4 z-10 grid h-9 w-9 place-items-center text-white cursor-pointer"
      aria-label="닫기"
    >
      <svg viewBox="0 0 24 24" class="h-5 w-5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
        <path d="M6 6l12 12M18 6L6 18" />
      </svg>
    </button>

    <div class="h-dvh w-full flex flex-col px-4 pt-14 pb-4">
      <div class="flex-1 flex items-center justify-center">
        <div class="relative w-full max-w-[520px]">
          <div
            id="lbViewport"
            class="relative mx-auto h-[70dvh] w-full overflow-hidden rounded-2xl shadow-2xl flex items-center justify-center touch-none"
          >
            <img
              id="lbImg"
              src=""
              alt="selected photo"
              class="absolute left-1/2 top-1/2 select-none"
              draggable="false"
            />
          </div>

          <button
            id="lbPrev"
            type="button"
            class="absolute left-2 sm:-left-10 top-1/2 -translate-y-1/2 z-20 grid h-9 w-9 place-items-center rounded-full bg-black/35 ring-1 ring-white/15 text-white backdrop-blur opacity-80 hover:opacity-100 transition cursor-pointer"
            aria-label="이전 사진"
          >
            <svg viewBox="0 0 24 24" class="h-5 w-5" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M15 18l-6-6 6-6" />
            </svg>
          </button>

          <button
            id="lbNext"
            type="button"
            class="absolute right-2 sm:-right-10 top-1/2 -translate-y-1/2 z-20 grid h-9 w-9 place-items-center rounded-full bg-black/35 ring-1 ring-white/15 text-white backdrop-blur opacity-80 hover:opacity-100 transition cursor-pointer"
            aria-label="다음 사진"
          >
            <svg viewBox="0 0 24 24" class="h-5 w-5" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 18l6-6-6-6" />
            </svg>
          </button>
        </div>
      </div>

      <p id="lbCount" class="mt-2 text-center text-xs text-white/70"></p>

      <div class="mt-3">
        <div class="mx-auto max-w-[520px] px-4">
          <div id="lbStrip" class="mt-3 flex gap-2 overflow-x-auto pb-1 scroll-smooth no-scrollbar">
            {photos.map((src, i) => (
              <button
                type="button"
                class="lb-thumb shrink-0 rounded-lg overflow-hidden ring-2 ring-transparent"
                data-thumb-index={i}
                aria-label={`썸네일 ${i + 1}`}
              >
                <img
                  src={src}
                  alt={`thumb ${i + 1}`}
                  class="h-14 w-14 object-cover opacity-70"
                  loading="lazy"
                  decoding="async"
                  draggable="false"
                />
              </button>
            ))}
          </div>
        </div>
      </div>
    </div>
  </div>

  <script is:inline define:vars={{ photos }}>
    const PHOTOS = photos;

    const lb = document.getElementById("lightbox");
    const lbImg = document.getElementById("lbImg");
    const lbCount = document.getElementById("lbCount");
    const strip = document.getElementById("lbStrip");

    const btnClose = document.getElementById("lbClose");
    const btnPrev = document.getElementById("lbPrev");
    const btnNext = document.getElementById("lbNext");

    const viewport = document.getElementById("lbViewport");
    const thumbButtons = Array.from(document.querySelectorAll("[data-thumb-index]"));

    // 성능/선명도 보정 (한 번만)
    lbImg.style.willChange = "transform";
    lbImg.style.transformOrigin = "center center";
    lbImg.style.imageRendering = "auto";

    let current = 0;

    // ===== base size (zoom=1에서의 "표시 크기") =====
    let baseW = 0;
    let baseH = 0;

    function measureBase() {
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;

      const naturalW = lbImg.naturalWidth || 1;
      const naturalH = lbImg.naturalHeight || 1;
      const r = Math.min(vw / naturalW, vh / naturalH);

      baseW = Math.round(naturalW * r);
      baseH = Math.round(naturalH * r);

      // ✅ base 크기로 고정 (여기서부터 확대는 transform scale만)
      lbImg.style.width = baseW + "px";
      lbImg.style.height = baseH + "px";
    }

    // ===== Zoom/Pan state =====
    let scale = 1;
    let tx = 0;
    let ty = 0;

    const MIN_SCALE = 1;
    const MAX_SCALE = 4;

    let isPanning = false;
    let isPinching = false;

    const pointers = new Map(); // id -> {x,y}
    let startDist = 0;
    let startScale = 1;
    let startTx = 0;
    let startTy = 0;

    // pinch anchor (이미지 좌표 기준)
    let pinchAnchorImgX = 0;
    let pinchAnchorImgY = 0;

    // swipe guard
    let multiTouch = false;
    let startX = null;

    // double tap guard
    let lastTap = 0;
    let justZoomed = false;

    // pinch cooldown
    let pinchCooldownUntil = 0;
    function markPinchCooldown(ms = 900) {
      pinchCooldownUntil = Date.now() + ms;
    }

    function clamp(n, a, b) {
      return Math.max(a, Math.min(b, n));
    }

    function applyTransform(withTransition = true) {
      lbImg.style.transition = withTransition ? "transform 120ms ease" : "none";
      lbImg.style.transform =
        `translate(calc(-50% + ${tx}px), calc(-50% + ${ty}px)) scale(${scale})`;
    }

    function clampPanByScale() {
      const vw = viewport.clientWidth;
      const vh = viewport.clientHeight;

      const imgW = baseW * scale;
      const imgH = baseH * scale;

      const maxX = Math.max(0, (imgW - vw) / 2);
      const maxY = Math.max(0, (imgH - vh) / 2);

      tx = clamp(tx, -maxX, maxX);
      ty = clamp(ty, -maxY, maxY);
    }

    function resetZoom() {
      scale = 1;
      tx = 0;
      ty = 0;
      applyTransform(true);
    }

    function toggleZoom() {
      if (scale === 1) {
        scale = 2;
      } else {
        scale = 1;
        tx = 0;
        ty = 0;
      }
      clampPanByScale();
      applyTransform(true);
    }

    // ===== Thumbs =====
    function updateNavButtons() {
      btnPrev.classList.toggle("hidden", current === 0);
      btnNext.classList.toggle("hidden", current === PHOTOS.length - 1);
    }

    function highlightThumb() {
      if (!strip) return;

      thumbButtons.forEach((btn) => {
        const img = btn.querySelector("img");
        btn.classList.remove("ring-white");
        btn.classList.add("ring-transparent");
        img.classList.remove("opacity-100");
        img.classList.add("opacity-70");
      });

      const activeBtn = thumbButtons[current];
      if (!activeBtn) return;

      const activeImg = activeBtn.querySelector("img");
      activeBtn.classList.remove("ring-transparent");
      activeBtn.classList.add("ring-white");
      activeImg.classList.remove("opacity-70");
      activeImg.classList.add("opacity-100");

      const max = Math.max(0, strip.scrollWidth - strip.clientWidth);

      if (current === 0) {
        strip.scrollTo({ left: 0, behavior: "smooth" });
        return;
      }
      if (current === PHOTOS.length - 1) {
        strip.scrollTo({ left: max, behavior: "smooth" });
        return;
      }

      const target = activeBtn.offsetLeft + activeBtn.offsetWidth / 2 - strip.clientWidth / 2;
      strip.scrollTo({ left: clamp(target, 0, max), behavior: "smooth" });
    }

    function render() {
      // 사진 바뀔 때만 초기화
      scale = 1;
      tx = 0;
      ty = 0;

      // onload는 매번 새로 바인딩(이전 핸들러 덮어쓰기)
      lbImg.onload = () => {
        measureBase();
        resetZoom();
      };

      // ✅ 라이트박스는 원본을 그대로 쓰자 (선명도)
      lbImg.decoding = "async";
      lbImg.loading = "eager";

      lbImg.src = PHOTOS[current];
      lbCount.textContent = `${current + 1} / ${PHOTOS.length}`;
      highlightThumb();
      updateNavButtons();
    }

    function openAt(index) {
      current = index;

      lb.classList.remove("hidden");
      lb.classList.add("block");
      lb.setAttribute("aria-hidden", "false");
      document.body.style.overflow = "hidden";

      render();
      setTimeout(render, 0);
    }

    function close() {
      lb.classList.add("hidden");
      lb.classList.remove("block");
      lb.setAttribute("aria-hidden", "true");
      lbImg.src = "";
      document.body.style.overflow = "";
      resetZoom();
    }

    function prev() {
      if (current === 0) return;
      current -= 1;
      render();
    }

    function next() {
      if (current === PHOTOS.length - 1) return;
      current += 1;
      render();
    }

    // ===== Open handlers =====
    document.querySelectorAll('[data-lightbox="open"]').forEach((btn) => {
      btn.addEventListener("click", () => openAt(Number(btn.dataset.index)));
    });

    thumbButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        current = Number(btn.dataset.thumbIndex);
        render();
      });
    });

    btnClose.addEventListener("click", (e) => { e.stopPropagation(); close(); });
    btnPrev.addEventListener("click", (e) => { e.stopPropagation(); prev(); });
    btnNext.addEventListener("click", (e) => { e.stopPropagation(); next(); });

    lb.addEventListener("click", (e) => { if (e.target === lb) close(); });

    window.addEventListener("keydown", (e) => {
      if (lb.classList.contains("hidden")) return;
      if (e.key === "Escape") close();
      if (e.key === "ArrowLeft") prev();
      if (e.key === "ArrowRight") next();
    });

    // ===== Double click (PC) =====
    viewport.addEventListener("dblclick", (e) => {
      e.preventDefault();
      toggleZoom();
    });

    // ===== Double tap (mobile) =====
    viewport.addEventListener("touchend", (e) => {
      if (Date.now() < pinchCooldownUntil || isPinching || multiTouch) {
        lastTap = 0;
        return;
      }

      e.preventDefault();

      const now = Date.now();
      if (now - lastTap < 280) {
        toggleZoom();
        lastTap = 0;

        justZoomed = true;
        setTimeout(() => (justZoomed = false), 250);
      } else {
        lastTap = now;
      }
    }, { passive: false });

    // ===== Pointer events for pan + pinch =====
    function getDistance(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }

    function getMid(a, b) {
      return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
    }

    // client 좌표 -> viewport 중심 기준 좌표
    function toViewportCenterXY(clientX, clientY) {
      const rect = viewport.getBoundingClientRect();
      const x = clientX - rect.left - rect.width / 2;
      const y = clientY - rect.top - rect.height / 2;
      return { x, y };
    }

    viewport.addEventListener("pointerdown", (e) => {
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
      viewport.setPointerCapture?.(e.pointerId);

      if (pointers.size === 2) {
        isPinching = true;
        isPanning = false;
        markPinchCooldown(900);

        const pts = Array.from(pointers.values());
        startDist = getDistance(pts[0], pts[1]);
        startScale = scale;
        startTx = tx;
        startTy = ty;

        const mid = getMid(pts[0], pts[1]);
        const v = toViewportCenterXY(mid.x, mid.y);

        // ✅ “핀치 중심”이 가리키는 이미지 좌표를 저장 (이게 핵심)
        pinchAnchorImgX = (v.x - startTx) / startScale;
        pinchAnchorImgY = (v.y - startTy) / startScale;

        multiTouch = true;
        startX = null;
        return;
      }

      if (scale > 1) {
        isPanning = true;
        isPinching = false;
        startTx = tx;
        startTy = ty;
        startDist = 0;
        startScale = scale;

        // pan 시작점
        const p = pointers.get(e.pointerId);
        e.__startPanX = p.x;
        e.__startPanY = p.y;
      }
    });

    viewport.addEventListener("pointermove", (e) => {
      if (!pointers.has(e.pointerId)) return;
      pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

      if (isPinching && pointers.size === 2) {
        const pts = Array.from(pointers.values());
        const dist = getDistance(pts[0], pts[1]);
        const mid = getMid(pts[0], pts[1]);

        let nextScale = startScale * (dist / startDist);
        nextScale = clamp(nextScale, MIN_SCALE, MAX_SCALE);

        const v = toViewportCenterXY(mid.x, mid.y);

        // ✅ 핀치 중심이 계속 같은 “이미지 지점”을 가리키게 tx/ty 재계산
        scale = nextScale;
        tx = v.x - pinchAnchorImgX * scale;
        ty = v.y - pinchAnchorImgY * scale;

        clampPanByScale();
        applyTransform(false);
        return;
      }

      if (isPanning && pointers.size === 1 && scale > 1) {
        const p = pointers.get(e.pointerId);

        // 첫 프레임에서 시작점이 없으면 잡아주기
        if (typeof viewport.__panStartX !== "number") {
          viewport.__panStartX = p.x;
          viewport.__panStartY = p.y;
          viewport.__panTx = tx;
          viewport.__panTy = ty;
        }

        const dx = p.x - viewport.__panStartX;
        const dy = p.y - viewport.__panStartY;

        tx = viewport.__panTx + dx;
        ty = viewport.__panTy + dy;

        clampPanByScale();
        applyTransform(false);
      }
    });

    function endPointer(e) {
      pointers.delete(e.pointerId);

      if (pointers.size < 2) {
        if (isPinching) markPinchCooldown(900);
        isPinching = false;
      }

      if (pointers.size === 0) {
        isPanning = false;
        viewport.__panStartX = undefined;
        viewport.__panStartY = undefined;
        viewport.__panTx = undefined;
        viewport.__panTy = undefined;

        // 너무 작아졌으면 원복
        if (scale <= 1.001) resetZoom();
        else applyTransform(true);

        multiTouch = false;
      }
    }

    viewport.addEventListener("pointerup", endPointer);
    viewport.addEventListener("pointercancel", endPointer);

    // ===== Swipe (mobile) for next/prev - ONLY when not zoomed =====
    lb.addEventListener("touchstart", (e) => {
      // 썸네일 드래그는 next/prev 금지
      if (e.target.closest("#lbStrip")) {
        startX = null;
        return;
      }

      if (e.touches.length > 1) {
        multiTouch = true;
        startX = null;
        return;
      }

      multiTouch = false;

      if (scale > 1) {
        startX = null;
        return;
      }

      startX = e.touches[0].clientX;
    }, { passive: true });

    lb.addEventListener("touchend", (e) => {
      if (e.target.closest("#lbStrip")) {
        startX = null;
        return;
      }

      if (justZoomed || isPanning || isPinching || multiTouch) {
        startX = null;
        multiTouch = false;
        return;
      }
      if (startX === null) return;

      if (scale > 1) {
        startX = null;
        return;
      }

      const endX = e.changedTouches[0].clientX;
      const dx = endX - startX;
      startX = null;

      if (Math.abs(dx) < 40) return;
      if (dx > 0) prev();
      else next();
    }, { passive: true });
  </script>
</section>
